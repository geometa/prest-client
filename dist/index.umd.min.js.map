{"version":3,"file":"index.umd.min.js","sources":["../src/api/client.ts"],"sourcesContent":["import { stringify } from 'querystring';\n\n/**\n * Options for creating a Prest API client.\n *\n * @export\n * @interface PrestApiClientOptions\n */\nexport interface PrestApiClientOptions {\n  /**\n   * The base URL of the Prest API endpoint.\n   */\n  base_url: string;\n\n  /**\n   * The username for authentication with the Prest API.\n   */\n  user_name: string;\n\n  /**\n   * The password for authentication with the Prest API.\n   */\n  password: string;\n\n  /**\n   * The name of the database to connect to.\n   */\n  database: string;\n}\n\n/**\n * A class that represents a chained query for interacting with a Prest API endpoint.\n *\n * This class allows you to build up a query by chaining various filter, function, and order methods.\n * Once the query is complete, you can call the `execute` method to execute the query and retrieve the results.\n */\nclass ChainedQuery {\n  private client: PrestApiClient;\n  private baseUrl: string;\n  private reqType: 'get' | 'post' | 'put' | 'delete';\n  private body: any;\n  private rendererArg: 'json' | 'xml' = 'json';\n  private sqlFunctions: string[] = [];\n  private chainedOperations: string[];\n\n  /**\n   * Creates a new ChainedQuery instance.\n   *\n   * @param client - The Prest API client to use for making the request.\n   * @param baseUrl - The base URL of the Prest API endpoint.\n   * @param reqType - The HTTP request type ('get', 'post', 'put', or 'delete').\n   * @param body - The data to send in the request body (for POST and PUT requests).\n   */\n  constructor(\n    client: PrestApiClient,\n    baseUrl: string,\n    reqType: 'get' | 'post' | 'put' | 'delete',\n    body: any,\n  ) {\n    this.client = client;\n    this.baseUrl = baseUrl;\n    this.reqType = reqType;\n    this.body = body;\n    this.chainedOperations = [];\n  }\n\n  /**\n   * Adds a page filter to the query, specifying which page of results to retrieve.\n   *\n   * This is useful for paginating large datasets.\n   * Prest API uses a zero-based indexing for pages, where the first page is `_page=0`.\n   *\n   * @param pageNumber - The page number (zero-based) to retrieve.\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the second page (10 items per page) of products\n   * const query = client.table('products').list()\n   *   .page(1)\n   *   .execute();\n   * ```\n   */\n  page(pageNumber: number): ChainedQuery {\n    this.chainedOperations.push(stringify({ _page: pageNumber }));\n    return this;\n  }\n\n  /**\n   * Adds a page size filter to the query, specifying the number of items to retrieve per page.\n   *\n   * This is useful in conjunction with `page` to control how many results are returned at a time.\n   *\n   * @param pageSize - The number of items per page.\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the first page (10 items per page) of customers\n   * const query = client.table('customers').list()\n   *   .pageSize(10)\n   *   .execute();\n   * ```\n   */\n  pageSize(pageSize: number): ChainedQuery {\n    this.chainedOperations.push(stringify({ _page_size: pageSize }));\n    return this;\n  }\n\n  /**\n   * Adds a select filter to the query, specifying which fields to retrieve from the results.\n   *\n   * By default, all fields are returned. Use this method to limit the response to only the fields you need.\n   *\n   * @param ...fields - A list of field names to select.\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve only the 'id', 'name', and 'price' fields from products\n   * const query = client.table('products').list()\n   *   .select('id', 'name', 'price')\n   *   .execute();\n   * ```\n   */\n  select(...fields: string[]): ChainedQuery {\n    this.chainedOperations.push(stringify({ _select: fields.join(',') }));\n    return this;\n  }\n\n  /**\n   * Adds a count filter to the query, which returns the total number of rows in the table.\n   *\n   * This is useful for getting the overall count of items without retrieving all results. You can optionally specify\n   * a field to count. By default, all fields (`*`) are counted.\n   *\n   * @param field - The field to count (optional, defaults to '*').\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Count the total number of products\n   * const query = client.table('products')\n   *   .count()\n   *   .execute();\n   *\n   * // Count the number of active users\n   * const query = client.table('users')\n   *   .count('is_active')\n   *   .execute();\n   * ```\n   */\n  count(field?: string): ChainedQuery {\n    const fieldValue = field ? field : '*';\n    this.chainedOperations.push(stringify({ _count: fieldValue }));\n    return this;\n  }\n\n  /**\n   * Adds a count_first filter to the query, which returns either the first row or the total count.\n   *\n   * This is useful for checking if there are any results or retrieving the first row quickly.\n   *\n   * @param countFirst - A boolean value indicating whether to return the first row (true) or the total count (false).\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Check if there are any active orders\n   * const query = client.table('orders')\n   *   .countFirst(true)\n   *   .execute();\n   *\n   * // Retrieve the first product\n   * const query = client.table('products')\n   *   .countFirst()\n   *   .execute();\n   * ```\n   */\n  countFirst(countFirst: boolean = true): ChainedQuery {\n    this.chainedOperations.push(stringify({ _count_first: countFirst }));\n    return this;\n  }\n\n  /**\n   * Sets the output renderer for the query results ('json' or 'xml').\n   *\n   * By default, the response is formatted as JSON. Use this method to specify XML instead.\n   *\n   * @param rendererArg - The desired output renderer ('json' or 'xml').\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve products in XML format\n   * const query = client.table('products')\n   *   .renderer('xml')\n   *   .execute();\n   * ```\n   */\n  renderer(rendererArg: 'json' | 'xml'): ChainedQuery {\n    this.chainedOperations.push(stringify({ _renderer: rendererArg }));\n    this.rendererArg = rendererArg;\n    return this;\n  }\n\n  /**\n   * Adds a distinct filter to the query, which removes duplicate rows from the result set.\n   *\n   * This is useful when you want to retrieve unique values from a column or combination of columns.\n   *\n   * @param distinct - A boolean value indicating whether to apply distinct filtering (true) or not (false).\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve distinct product categories\n   * const query = client.table('products').list()\n   *   .distinct(true)\n   *   .execute();\n   * ```\n   */\n  distinct(distinct: boolean = true): ChainedQuery {\n    this.chainedOperations.push(stringify({ _distinct: distinct }));\n    return this;\n  }\n\n  /**\n   * Adds an order filter to the query, specifying the order in which the results should be returned.\n   *\n   * Use a minus sign (-) prefix to indicate descending order for a field.\n   *\n   * @param ...fields - A list of field names to order by. Prefix field names with '-' for descending order.\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve products ordered by price in descending order\n   * const query = client.table('products').list()\n   *   .order('-price')\n   *   .execute();\n   *\n   * // Retrieve products ordered by price in ascending order, then by name in descending order\n   * const query = client.table('products').list()\n   *   .order('price', '-name')\n   *   .execute();\n   * ```\n   */\n  order(...fields: string[]): ChainedQuery {\n    const orderFields = fields.map((field) =>\n      field.startsWith('-') ? field : `${field}`,\n    );\n    this.chainedOperations.push(stringify({ _order: orderFields.join(',') }));\n    return this;\n  }\n\n  /**\n   * Adds a group by filter to the query, grouping the results based on the specified fields.\n   *\n   * This is useful when you want to perform aggregate functions (such as SUM, AVG, etc.) on grouped data.\n   *\n   * @param ...fields - A list of field names to group by.\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve total sales amount grouped by product category\n   * const query = client.table('sales').list()\n   *   .groupBy('product_category')\n   *   .sum('sales_amount')\n   *   .execute();\n   * ```\n   */\n  groupBy(...fields: string[]): ChainedQuery {\n    this.chainedOperations.push(stringify({ _groupby: fields.join(',') }));\n    return this;\n  }\n\n  /**\n   * Adds an equal filter to the query, specifying that a field must be equal to a certain value.\n   *\n   * @param field - The field to filter by.\n   * @param value - The value that the field must be equal to.\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve products with the 'category' field equal to 'electronics'\n   * const query = client.table('products').list()\n   *   .filterEqual('category', 'electronics')\n   *   .execute();\n   * ```\n   */\n  filterEqual(field: string, value: any): ChainedQuery {\n    this.chainedOperations.push(`${field}=${encodeURIComponent(value)}`);\n    return this;\n  }\n  /**\n   * Adds a Sum function to the query, calculating the sum of values in the specified field.\n   *\n   * This is useful when you want to aggregate numerical values across grouped data.\n   *\n   * @param field - The field for which to calculate the sum.\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the sum of category IDs grouped by category\n   * const query = client.table('categories').list()\n   *   .groupBy('category_id')\n   *   .sum('category_id')\n   *   .execute();\n   * ```\n   */\n  sum(field: string): ChainedQuery {\n    this.sqlFunctions.push(`sum:${field}`);\n    return this;\n  }\n\n  /**\n   * Adds an Avg function to the query, calculating the average of values in the specified field.\n   *\n   * This is useful when you want to find the average value of a numerical field across grouped data.\n   *\n   * @param field - The field for which to calculate the average.\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the average of category IDs grouped by category\n   * const query = client.table('categories').list()\n   *   .groupBy('category_id')\n   *   .avg('category_id')\n   *   .execute();\n   * ```\n   */\n  avg(field: string): ChainedQuery {\n    this.sqlFunctions.push(`avg:${field}`);\n    return this;\n  }\n\n  /**\n   * Adds a Max function to the query, finding the maximum value in the specified field.\n   *\n   * This is useful when you want to find the maximum value of a field across grouped data.\n   *\n   * @param field - The field for which to find the maximum value.\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the maximum category ID grouped by category\n   * const query = client.table('categories').list()\n   *   .groupBy('category_id')\n   *   .max('category_id')\n   *   .execute();\n   * ```\n   */\n  max(field: string): ChainedQuery {\n    this.sqlFunctions.push(`max:${field}`);\n    return this;\n  }\n\n  /**\n   * Adds a Min function to the query, finding the minimum value in the specified field.\n   *\n   * This is useful when you want to find the minimum value of a field across grouped data.\n   *\n   * @param field - The field for which to find the minimum value.\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the minimum category ID grouped by category\n   * const query = client.table('categories').list()\n   *   .groupBy('category_id')\n   *   .min('category_id')\n   *   .execute();\n   * ```\n   */\n  min(field: string): ChainedQuery {\n    this.sqlFunctions.push(`min:${field}`);\n    return this;\n  }\n\n  /**\n   * Adds a StdDev function to the query, calculating the standard deviation of values in the specified field.\n   *\n   * This is useful when you want to analyze the variability of numerical data across grouped data.\n   *\n   * @param field - The field for which to calculate the standard deviation.\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the standard deviation of category IDs grouped by category\n   * const query = client.table('categories').list()\n   *   .groupBy('category_id')\n   *   .stdDev('category_id')\n   *   .execute();\n   * ```\n   */\n  stdDev(field: string): ChainedQuery {\n    this.sqlFunctions.push(`stddev:${field}`);\n    return this;\n  }\n\n  /**\n   * Adds a Variance function to the query, calculating the variance of values in the specified field.\n   *\n   * This is useful when you want to measure the spread or dispersion of numerical data across grouped data.\n   *\n   * @param field - The field for which to calculate the variance.\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the variance of category IDs grouped by category\n   * const query = client.table('categories').list()\n   *   .groupBy('category_id')\n   *   .variance('category_id')\n   *   .execute();\n   * ```\n   */\n  variance(field: string): ChainedQuery {\n    this.sqlFunctions.push(`variance:${field}`);\n    return this;\n  }\n\n  /**\n   * Adds a having filter to the query, specifying a condition for aggregated values after grouping.\n   *\n   * This is useful when you want to filter grouped results based on aggregated values.\n   *\n   * @param groupFunc - The aggregation function to apply the condition to (e.g., 'sum', 'avg', 'min', 'max', etc.).\n   * @param field - The field to which the condition applies.\n   * @param condition - The condition operator (e.g., '$gt', '$lt', '$eq', etc.).\n   * @param value - The value to compare against.\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Retrieve categories where the sum of category IDs is greater than 5\n   * const query = client.table('categories').list()\n   *   .groupBy('category_id')\n   *   .sum('category_id')\n   *   .having('sum', 'category_id', '$gt', 5)\n   *   .execute();\n   * ```\n   */\n  having(\n    groupFunc: string,\n    field: string,\n    condition: string,\n    value: any,\n  ): ChainedQuery {\n    const havingClause = `having:${groupFunc}:${field}:${condition}:${encodeURIComponent(value)}`;\n    this.chainedOperations.push(havingClause);\n    return this;\n  }\n\n  /**\n   * Filters results based on a field being within a specific range.\n   *\n   * @param field The name of the field to filter on.\n   * @param start (optional) The lower bound of the range (inclusive).\n   * @param end (optional) The upper bound of the range (inclusive).\n   * @returns A chained query object for further building the query.\n   *\n   * @example\n   * ```typescript\n   * // Filter categories where 'category_id' is between 200 and 300 (inclusive)\n   * const response = await client\n   *   .table('categories')\n   *   .list()\n   *   .filterRange('category_id', 200, 300)\n   *   .execute();\n   * ```\n   *\n   * @example\n   * // Filter categories where 'category_id' is greater than or equal to 200\n   * const response = await client\n   *   .table('categories')\n   *   .list()\n   *   .filterRange('category_id', 200)\n   *   .execute();\n   * ```\n   */\n  filterRange(field: string, start?: any, end?: any): ChainedQuery {\n    if (start !== undefined) {\n      this.chainedOperations.push(`${field}=$gte.${encodeURIComponent(start)}`);\n    }\n    if (end !== undefined) {\n      this.chainedOperations.push(`${field}=$lte.${encodeURIComponent(end)}`);\n    }\n    return this;\n  }\n\n  /**\n   * Performs a join between tables.\n   *\n   * @param type The type of join to perform (e.g., 'inner', 'left', 'right').\n   * @param table The name of the table to join with.\n   * @param leftField The field name from the current table.\n   * @param operator The comparison operator to use (e.g., '$eq', '$gt', '$lt').\n   * @param rightField The field name from the joined table.\n   * @returns A chained query object for further building the query.\n   *\n   * @example\n   * ```typescript\n   * // Perform an inner join between 'categories' and 'products' tables\n   * const response = await client\n   *   .table('categories')\n   *   .list()\n   *   .join(\n   *     'inner',\n   *     'products',\n   *     'categories.category_id',\n   *     '$eq',\n   *     'products.category_id',\n   *   )\n   *   .execute();\n   * ```\n   */\n  join(\n    joinType: 'inner' | 'left' | 'right' | 'outer',\n    jointable: string,\n    localField: string,\n    operator: string,\n    foreignField: string,\n  ): ChainedQuery {\n    const joinClause = `_join=${joinType}:${jointable}:${localField}:${operator}:${foreignField}`;\n    this.chainedOperations.push(joinClause);\n    return this;\n  }\n\n  /**\n   * Filters results based on a JSON field using a JSONB path expression.\n   *\n   * @param field The name of the JSON field to filter on.\n   * @param path The JSONB path expression to use for filtering.\n   * @param value The value to compare against the path in the JSON field.\n   * @returns A chained query object for further building the query.\n   *\n   * @example\n   * ```typescript\n   * // Assuming a 'mock_json' table with a 'jsonb_data' field containing JSON data\n   * const response = await client\n   *   .table('mock_json')\n   *   .list()\n   *   .jsonbFilter('jsonb_data', 'tags', 1)\n   *   .execute();\n   * ```\n   */\n  jsonbFilter(field: string, jsonField: string, value: any): ChainedQuery {\n    const filterClause = `${field}->>${jsonField}:jsonb=${encodeURIComponent(value)}`;\n    this.chainedOperations.push(filterClause);\n    return this;\n  }\n\n  /**\n   * Adds a full-text search filter to the query using tsquery syntax.\n   *\n   * @param field - The field to perform the text search on.\n   * @param query - The tsquery string representing the search query.\n   * @param language - The language to tokenize the query in (optional).\n   * @returns The ChainedQuery instance to allow for method chaining.\n   *\n   * @example\n   * ```typescript\n   * // Perform a full-text search for documents containing 'fat' and 'rat'\n   * const query = client.table('documents').list()\n   *   .textSearch('content', 'fat & rat')\n   *   .execute();\n   *\n   * // Perform a full-text search in Portuguese language for documents containing 'gato' and 'cão'\n   * const query = client.table('documents').list()\n   *   .textSearch('content', 'gato & cão', 'portuguese')\n   *   .execute();\n   * ```\n   */\n  textSearch(field: string, query: string, language?: string): ChainedQuery {\n    const tsQuery = `${field}${language ? '$' + language : ''}:tsquery=${encodeURIComponent(query)}`;\n    this.chainedOperations.push(tsQuery);\n    return this;\n  }\n\n  /**\n   * Executes the chained query operations and returns the result.\n   *\n   * @returns A promise that resolves with the query result.\n   */\n  async execute(): Promise<any> {\n    let chainedUrl = this.baseUrl;\n\n    if (this.chainedOperations.length > 0) {\n      chainedUrl += `?${this.chainedOperations[0]}`;\n\n      for (let i = 1; i < this.chainedOperations.length; i++) {\n        chainedUrl += `&${this.chainedOperations[i]}`;\n      }\n    }\n\n    if (this.sqlFunctions.length > 0) {\n      chainedUrl += `&_select=${this.sqlFunctions.join(',')}`;\n    }\n\n    try {\n      console.log(chainedUrl);\n      const httpClientMethod = this.client.getHttpClientMethod(this.reqType);\n      const response = await httpClientMethod(chainedUrl, this.body);\n\n      if (this.rendererArg === 'json') {\n        return response.json();\n      } else {\n        return response.text();\n      }\n    } catch (error: any) {\n      throw new Error(`Failed to make API request: ${error.message}`);\n    }\n  }\n}\n\n/**\n * A client for interacting with a Prest API.\n *\n * @export\n * @class PrestApiClient\n */\nexport class PrestApiClient {\n  /**\n   * The underlying HTTP client for making requests to the Prest API.\n   */\n  private client:\n    | undefined\n    | {\n        get: (url: string) => Promise<Response>;\n        post: (url: string, body: any) => Promise<Response>;\n        put: (url: string, body: any) => Promise<Response>;\n        delete: (url: string) => Promise<Response>;\n      };\n\n  /**\n   * The options used to configure the client.\n   */\n  private options: PrestApiClientOptions;\n\n  /**\n   * Creates a new Prest API client with the provided options.\n   *\n   * @param options - The options for creating the client.\n   */\n  constructor(options: PrestApiClientOptions) {\n    this.options = options;\n    this.createClient();\n  }\n\n  /**\n   * Creates the underlying HTTP client with the necessary authentication headers.\n   */\n  private async createClient() {\n    try {\n      const username = this.options.user_name;\n      const password = this.options.password;\n      const authHeader = 'Basic ' + btoa(username + ':' + password);\n\n      this.client = {\n        get: async (url: string) => {\n          const response = await fetch(url, {\n            headers: {\n              Authorization: authHeader,\n            },\n          });\n\n          if (!response.ok) {\n            throw new Error(`Failed to fetch data: ${response.statusText}`);\n          }\n\n          return response;\n        },\n        post: async (url: string, body: any) => {\n          const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              'Authorization': authHeader,\n            },\n            body: JSON.stringify(body),\n          });\n\n          if (!response.ok) {\n            throw new Error(`Failed to insert data: ${response.statusText}`);\n          }\n\n          return response;\n        },\n        put: async (url: string, body: any) => {\n          const response = await fetch(url, {\n            method: 'PUT',\n            headers: {\n              'Content-Type': 'application/json',\n              'Authorization': authHeader,\n            },\n            body: JSON.stringify(body),\n          });\n\n          if (!response.ok) {\n            throw new Error(`Failed to update data: ${response.statusText}`);\n          }\n\n          return response;\n        },\n        delete: async (url: string) => {\n          const response = await fetch(url, {\n            method: 'DELETE',\n            headers: {\n              Authorization: authHeader,\n            },\n          });\n\n          if (!response.ok) {\n            throw new Error(`Failed to delete data: ${response.statusText}`);\n          }\n\n          return response;\n        },\n      };\n    } catch (error) {\n      console.error('Error creating client:', error);\n    }\n  }\n\n  /**\n   * Returns the appropriate HTTP client method for making the API request.\n   *\n   * @param method - The HTTP method to use ('get', 'post', 'put', or 'delete').\n   * @returns The corresponding HTTP client method.\n   * @throws An error if the client is not initialized or the method is invalid.\n   */\n  getHttpClientMethod(method: 'get' | 'post' | 'put' | 'delete') {\n    if (!this.client) {\n      throw new Error('Client not initialized');\n    }\n\n    switch (method) {\n      case 'get':\n        return this.client.get;\n      case 'post':\n        return this.client.post;\n      case 'put':\n        return this.client.put;\n      case 'delete':\n        return this.client.delete;\n      default:\n        throw new Error('Invalid HTTP method');\n    }\n  }\n\n  /**\n   * Returns an object for interacting with a specific table in the database.\n   *\n   * @param tableName - The name of the table.\n   * @returns An object with methods for interacting with the table.\n   */\n  table(tableName: string | undefined): {\n    /**\n     * Retrieves the structure of the specified table.\n     *\n     * @returns A promise that resolves with the table structure.\n     * @throws An error if fetching the table structure fails.\n     *\n     * @example\n     * const response = await client.table('user').list();\n     * // Queries the rows of the 'user' table. Public schema is used by default.\n     * // Executes GET `/:database/:schema/:table`.\n     *\n     * @example\n     * const response = await client.table('private.user').list();\n     * // Retrieves the rows of the 'user' table in the 'private' schema.\n     * // Executes GET `/:database/:schema/:table`.\n     *\n     * @example\n     * const response = await client.table('public.').list();\n     * // Retrieves a list of tables in the 'public' schema.\n     * // Executes GET `/:database/:schema`.\n     * // Note: The dot at the end is to ignore the table name.\n     */\n    list: () => ChainedQuery;\n\n    /**\n     * Retrieves data from the specified table.\n     *\n     * @returns A promise that resolves with the data from the table.\n     * @throws An error if fetching data from the table fails.\n     *\n     * @example\n     * const response = await client.table('user').show();\n     * // Retrieves data from the 'user' table.\n     * // Executes GET `/show/:database/:schema/:table`.\n     */\n    show: () => ChainedQuery;\n\n    /**\n     * Inserts data into the specified table.\n     *\n     * @param data - The data to insert, structured as a JavaScript object with properties matching the table's columns.\n     * @returns A promise that resolves with the inserted data, including any generated IDs or timestamps.\n     * @throws An error if inserting data fails.\n     *\n     * @example\n     * const response = await client.table('user').insert({\n     *   user_name: 'Ronaldo',\n     *   description: 'Siuuu!!!',\n     *   picture: '\\\\x',\n     * });\n     * // Inserts a new row into the 'user' table.\n     * // Executes POST `/:database/:schema/:table`.\n     */\n    insert: (data: any) => ChainedQuery;\n\n    /**\n     * Inserts multiple rows of data into the table in a single request.\n     *\n     * @param data An array of objects representing the data to insert.\n     *                 Each object should have properties matching the table's columns.\n     * @returns A promise resolving to an array containing the inserted rows.\n     *         Each row will have the same structure as the provided data objects,\n     *         including any server-generated values (e.g., auto-incrementing IDs).\n     *\n     * @example\n     * ```typescript\n     * const data = [\n     *   {\n     *     category_name: 'Category 1',\n     *     description: 'Description 1',\n     *     picture: '\\\\x',\n     *   },\n     *   {\n     *     category_name: 'Category 2',\n     *     description: 'Description 2',\n     *     picture: '\\\\x',\n     *   },\n     * ];\n     *\n     * const response = await client\n     *   .table('categories')\n     *   .batchInsert(data)\n     *   .execute();\n     *\n     * console.log(response);\n     * // response will be an array of inserted objects with potentially added server-generated IDs\n     * ```\n     */\n    batchInsert: (data: any[]) => ChainedQuery;\n\n    /**\n     * Updates data in the specified table based on the provided field and value.\n     *\n     * @param field - The field to filter by for updating.\n     * @param value - The value of the field to filter by for updating.\n     * @param data - The data to update, structured as a JavaScript object with properties matching the table's columns.\n     * @returns A promise that resolves with the updated data.\n     * @throws An error if updating data fails.\n     *\n     * @example\n     * const response = await client.table('user').update(\n     *   'user_id', // Field to filter by\n     *   userIdToUpdate, // Value of the field to filter by\n     *   {\n     *     user_name: 'NewName',\n     *     description: 'Updated description',\n     *     picture: '\\\\x',\n     *   }\n     * );\n     * // Updates data in the 'user' table where 'user_id' equals 'userIdToUpdate'.\n     * // Executes PUT `/:database/:schema/:table?field=value`.\n     */\n    update: (data: any) => ChainedQuery;\n\n    /**\n     * Deletes data from the specified table based on the provided field and value.\n     *\n     * @param field - The field to filter by for deletion.\n     * @param value - The value of the field to filter by for deletion.\n     * @returns A promise that resolves when the data is successfully deleted.\n     * @throws An error if deleting data fails.\n     *\n     * @example\n     * const response = await client.table('user').delete(\n     *   'user_id', // Field to filter by\n     *   userIdToDelete // Value of the field to filter by\n     * );\n     * // Deletes data from the 'user' table where 'user_id' equals 'userIdToDelete'.\n     * // Executes DELETE `/:database/:schema/:table?field=value`.\n     */\n    delete: () => ChainedQuery;\n  } {\n    if (!this.client) {\n      throw new Error('Client not initialized');\n    }\n\n    if (!tableName) {\n      throw new Error('table name is required');\n    }\n\n    let schemaName: string = 'public';\n    if (tableName.includes('.')) {\n      const parts = tableName.split('.');\n      schemaName = parts[0] || schemaName;\n      tableName = parts[1];\n    }\n\n    return {\n      list: (): ChainedQuery => {\n        const baseUrl = `${this.base_url}/${this.database}/${schemaName}/${tableName}`;\n        return new ChainedQuery(this, baseUrl, 'get', null);\n      },\n\n      show: (): ChainedQuery => {\n        const baseUrl = `${this.base_url}/show/${this.database}/${schemaName}/${tableName}`;\n        return new ChainedQuery(this, baseUrl, 'get', null);\n      },\n      insert: (data: any): ChainedQuery => {\n        const baseUrl = `${this.base_url}/${this.database}/${schemaName}/${tableName}`;\n        return new ChainedQuery(this, baseUrl, 'post', data);\n      },\n      batchInsert: (data: any): ChainedQuery => {\n        const baseUrl = `${this.base_url}/batch/${this.database}/${schemaName}/${tableName}`;\n        return new ChainedQuery(this, baseUrl, 'post', data);\n      },\n      update: (data: any): ChainedQuery => {\n        const baseUrl = `${this.base_url}/${this.database}/${schemaName}/${tableName}`;\n        return new ChainedQuery(this, baseUrl, 'put', data);\n      },\n      delete: (): ChainedQuery => {\n        const baseUrl = `${this.base_url}/${this.database}/${schemaName}/${tableName}`;\n        return new ChainedQuery(this, baseUrl, 'delete', null);\n      },\n    };\n  }\n\n  /**\n   * Gets the name of the database to which the client is connected.\n   */\n  get database(): string {\n    return this.options.database;\n  }\n\n  /**\n   * Gets the base URL of the Prest API endpoint to which the client is connected.\n   */\n  get base_url(): string {\n    return this.options.base_url;\n  }\n}\n"],"names":["ChainedQuery","client","baseUrl","reqType","body","this","rendererArg","sqlFunctions","chainedOperations","prototype","page","pageNumber","push","stringify","_page","pageSize","_page_size","select","fields","_i","arguments","length","_select","join","count","field","fieldValue","_count","countFirst","_count_first","renderer","_renderer","distinct","_distinct","order","orderFields","map","startsWith","concat","_order","groupBy","_groupby","filterEqual","value","encodeURIComponent","sum","avg","max","min","stdDev","variance","having","groupFunc","condition","havingClause","filterRange","start","end","undefined","joinType","jointable","localField","operator","foreignField","joinClause","jsonbFilter","jsonField","filterClause","textSearch","query","language","tsQuery","execute","chainedUrl","i","console","log","getHttpClientMethod","httpClientMethod","response","_a","sent","json","text","Error","error_1","message","PrestApiClient","options","createClient","username","user_name","password","authHeader_1","btoa","get","url","__awaiter","_this","fetch","headers","Authorization","ok","statusText","post","method","JSON","put","delete","error","table","tableName","schemaName","includes","parts","split","list","base_url","database","show","insert","data","batchInsert","update","Object","defineProperty"],"mappings":"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"}